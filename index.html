<html>

<head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
    
<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;
    
    varying vec4 vColor;

    void main(void) {
        gl_FragColor = vColor;
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    uniform mat4 uPMatrix;
    uniform mat4 uMVMatrix;
    
    attribute vec4 aVertexColor;
    attribute vec3 aVertexPosition;
    
    varying vec4 vColor;

    void main(void) {
        vColor = aVertexColor;
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
    }
</script>

<script type="text/javascript">
    function initGl(canvas) {
        var gl = canvas.getContext("experimental-webgl");
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);
        return gl;
    }



    function createShader(gl, shaderType, shaderScriptId) {
        var shader = gl.createShader(shaderType);
        gl.shaderSource(shader, document.getElementById(shaderScriptId).text);
        gl.compileShader(shader)
        return shader;
    }

    function initShaders(gl) {
        var shaderProgram = gl.createProgram();

        gl.attachShader(shaderProgram, createShader(gl, gl.VERTEX_SHADER, "shader-vs"));
        gl.attachShader(shaderProgram, createShader(gl, gl.FRAGMENT_SHADER, "shader-fs"));

        gl.linkProgram(shaderProgram);

        gl.useProgram(shaderProgram);

        gl.enableVertexAttribArray(gl.getAttribLocation(shaderProgram, "aVertexPosition"));
        gl.enableVertexAttribArray(gl.getAttribLocation(shaderProgram, "aVertexColor"));

        return shaderProgram;
    }



    function createArrayBuffer(gl, options) {
        var b = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, b);
        if (typeof options !== 'undefined') { // copy properties from options to b
            Object.keys(options).forEach(function(k) {
                b[k] = options[k];
            });
        }
        return b;
    }

    function initBuffers(gl) {
        var buffers = [];

        // pyramid position
        var trianglePositionBuffer = createArrayBuffer(gl, {
            itemSize: 3,
            numItems: 12,
            glDrawMode: gl.TRIANGLES
        });
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            // Front face
             0.0,  1.0,  0.0,
            -1.0, -1.0,  1.0,
             1.0, -1.0,  1.0,
            // Right face
             0.0,  1.0,  0.0,
             1.0, -1.0,  1.0,
             1.0, -1.0, -1.0,
            // Back face
             0.0,  1.0,  0.0,
             1.0, -1.0, -1.0,
            -1.0, -1.0, -1.0,
            // Left face
             0.0,  1.0,  0.0,
            -1.0, -1.0, -1.0,
            -1.0, -1.0,  1.0
        ]), gl.STATIC_DRAW);

        // pyramid color
        var triangleColorBuffer = createArrayBuffer(gl, {
            itemSize: 4
        });
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            // Front face
            1.0, 0.0, 0.0, 1.0,
            1.0, 0.0, 0.0, 1.0,
            1.0, 0.0, 0.0, 1.0,
            // Right face
            0.0, 1.0, 0.0, 1.0,
            0.0, 1.0, 0.0, 1.0,
            0.0, 1.0, 0.0, 1.0,
            // Back face
            0.0, 0.0, 1.0, 1.0,
            0.0, 0.0, 1.0, 1.0,
            0.0, 0.0, 1.0, 1.0,
            // Left face
            1.0, 1.0, 0.0, 1.0,
            1.0, 1.0, 0.0, 1.0,
            1.0, 1.0, 0.0, 1.0,
        ]), gl.STATIC_DRAW);

        buffers.push({
            position: trianglePositionBuffer,
            color: triangleColorBuffer,
            translation: [0.0, 0.0, -20.0],
            rotation: {x: 0, y: 0, z: 0}
        });


        // bottom square position
        var squarePositionBuffer = createArrayBuffer(gl, {
            itemSize: 3,
            numItems: 4,
            glDrawMode: gl.TRIANGLE_STRIP
        });
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1.0, -1.0,  -1.0,
             1.0, -1.0,  -1.0,
            -1.0, -1.0,  1.0,
             1.0, -1.0,  1.0,
        ]), gl.STATIC_DRAW);

        // bottom square color
        var squareColorBuffer = createArrayBuffer(gl, {
            itemSize: 4
        });
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
             1.0, 1.0, 1.0, 1.0,
             1.0, 1.0, 1.0, 1.0,
             1.0, 1.0, 1.0, 1.0,
             1.0, 1.0, 1.0, 1.0
        ]), gl.STATIC_DRAW);
        
        buffers.push({
            position: squarePositionBuffer,
            color: squareColorBuffer,
            translation: [0.0, 0.0, -20.0],
            rotation: {x: 0, y: 0, z: 0}
        });
        

        return buffers;
    }



    function drawScene(gl, shaderProgram, buffers, viewportWidth, viewportHeight) {
        // set up viewport and clear
        gl.viewport(0, 0, viewportWidth, viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // create perspective matrix and write into uniform
        var pMatrix = mat4.create();
        mat4.perspective(10, viewportWidth / viewportHeight, 0.1, 100.0, pMatrix);
        gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uPMatrix"), false, pMatrix);

        // draw buffers
        buffers.forEach(function(buffer) {
            // create mv matrix, apply translation and rotation, set mv uniform
            var mvMatrix = mat4.create();
            mat4.identity(mvMatrix);
            mat4.translate(mvMatrix, buffer.translation);
            mat4.rotateX(mvMatrix, buffer.rotation.x * Math.PI/180);
            mat4.rotateY(mvMatrix, buffer.rotation.y * Math.PI/180);
            mat4.rotateZ(mvMatrix, buffer.rotation.z * Math.PI/180);
            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMVMatrix"), false, mvMatrix);            
         
            // set color attrib
            var color = buffer.color;
            gl.bindBuffer(gl.ARRAY_BUFFER, color);
            gl.vertexAttribPointer(gl.getAttribLocation(shaderProgram, "aVertexColor"), color.itemSize, gl.FLOAT, false, 0, 0);
           
            // set position attrib
            var position = buffer.position;
            gl.bindBuffer(gl.ARRAY_BUFFER, position);
            gl.vertexAttribPointer(gl.getAttribLocation(shaderProgram, "aVertexPosition"), position.itemSize, gl.FLOAT, false, 0, 0);

            // draw
            gl.drawArrays(position.glDrawMode, 0, position.numItems);
        });
    }

    function animateScene(buffers) {
        buffers.forEach(function(buffer) {
            buffer.rotation.x = buffer.rotation.x == 360 ? 0 : buffer.rotation.x + 1;
            buffer.rotation.y = buffer.rotation.y == 360 ? 0 : buffer.rotation.y + 1;
            buffer.rotation.z = buffer.rotation.z == 360 ? 0 : buffer.rotation.z + 2;
        });
    }

    function webGlInit() {
        var canvas =  document.getElementById("c");
        var gl = initGl(canvas);
        var shaderProgram = initShaders(gl);
        var buffers = initBuffers(gl);
        return function() { // return function to update scene
            animateScene(buffers);
            drawScene(gl, shaderProgram, buffers, canvas.width, canvas.height);
        };
    }

    function start() {
        var updateSceneFn = webGlInit();
        (function() {
            updateSceneFn();
            requestAnimationFrame(arguments.callee); // arguments.callee is a reference to this (anonymous) function
        })();
    }
</script>

</head>

<body onload="start();">
    <canvas id="c" style="border: none;" width="500" height="500"></canvas>
</body>

</html>