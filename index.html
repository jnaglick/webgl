<html>

<head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
    
<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;
    
    uniform sampler2D uSampler;

    varying vec2 vTextureCoord;

    void main(void) {
        gl_FragColor = texture2D(uSampler, vTextureCoord);
        //gl_FragColor = vec4(1.0, 0.0, 1.0, 0.3);
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    
    attribute vec3 aVertexPosition;
    attribute vec2 aTextureCoord;

    varying vec2 vTextureCoord;

    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vTextureCoord = aTextureCoord;
    }
</script>

<script type="text/javascript">
    function initGl(canvas) {
        var gl = canvas.getContext("experimental-webgl");
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);
        return gl;
    }



    function createShader(gl, shaderType, shaderScriptId) {
        var shader = gl.createShader(shaderType);
        gl.shaderSource(shader, document.getElementById(shaderScriptId).text);
        gl.compileShader(shader)
        return shader;
    }

    function initShaders(gl) {
        var shaderProgram = gl.createProgram();

        gl.attachShader(shaderProgram, createShader(gl, gl.VERTEX_SHADER, "shader-vs"));
        gl.attachShader(shaderProgram, createShader(gl, gl.FRAGMENT_SHADER, "shader-fs"));

        gl.linkProgram(shaderProgram);

        gl.useProgram(shaderProgram);

        gl.enableVertexAttribArray(gl.getAttribLocation(shaderProgram, "aVertexPosition"));
        gl.enableVertexAttribArray(gl.getAttribLocation(shaderProgram, "aTextureCoord"));

        return shaderProgram;
    }



    function createArrayBuffer(gl, options) {
        var b = gl.createBuffer();
        if (typeof options !== 'undefined') { // copy properties from options to b
            Object.keys(options).forEach(function(k) {
                b[k] = options[k];
            });
        }
        return b;
    }

    function setArrayBufferData(gl, buffer, data) {
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);        
    }

    function setElementArrayBufferData(gl, buffer, data) {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW);        
    }

    function createCubeFigure(gl, translation, rotation, animateFn) {
        // position buffer
        var cubePositionBuffer = createArrayBuffer(gl, {
            itemSize: 3
        });
        setArrayBufferData(gl, cubePositionBuffer, new Float32Array([ 
            // Front face
            -1.0, -1.0,  1.0,
             1.0, -1.0,  1.0,
             1.0,  1.0,  1.0,
            -1.0,  1.0,  1.0,
            // Back face
            -1.0, -1.0, -1.0,
            -1.0,  1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0, -1.0, -1.0,
            // Top face
            -1.0,  1.0, -1.0,
            -1.0,  1.0,  1.0,
             1.0,  1.0,  1.0,
             1.0,  1.0, -1.0,
            // Bottom face
            -1.0, -1.0, -1.0,
            -1.0, -1.0,  1.0,
             1.0, -1.0,  1.0,
             1.0, -1.0, -1.0,
            // Right face
             1.0, -1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0,  1.0,  1.0,
             1.0, -1.0,  1.0,
            // Left face
            -1.0, -1.0, -1.0,
            -1.0, -1.0,  1.0,
            -1.0,  1.0,  1.0,
            -1.0,  1.0, -1.0,
        ]));

        // texture buffer
        var cubeTextureBuffer = createArrayBuffer(gl, {
            itemSize: 2
        });
        setArrayBufferData(gl, cubeTextureBuffer, new Float32Array([
            // Front face
            0.0, 0.0,
            1.0, 0.0,
            1.0, 1.0,
            0.0, 1.0,
            // Back face
            1.0, 0.0,
            1.0, 1.0,
            0.0, 1.0,
            0.0, 0.0,
            // Top face
            0.0, 1.0,
            0.0, 0.0,
            1.0, 0.0,
            1.0, 1.0,
            // Bottom face
            0.0, 1.0,
            0.0, 0.0,
            1.0, 0.0,
            1.0, 1.0,
            // Right face
            1.0, 0.0,
            1.0, 1.0,
            0.0, 1.0,
            0.0, 0.0,
            // Left face
            0.0, 0.0,
            1.0, 0.0,
            1.0, 1.0,
            0.0, 1.0,
        ]));

        // index buffer
        var cubeIndexBuffer = createArrayBuffer(gl, {
            numItems: 36
        });
        setElementArrayBufferData(gl, cubeIndexBuffer, new Uint16Array([
            0, 1, 2,      0, 2, 3,    // Front face
            4, 5, 6,      4, 6, 7,    // Back face
            8, 9, 10,     8, 10, 11,  // Top face
            12, 13, 14,   12, 14, 15, // Bottom face
            16, 17, 18,   16, 18, 19, // Right face
            20, 21, 22,   20, 22, 23  // Left face
        ]));

        return {
            buffers: [{position: cubePositionBuffer, texture: cubeTextureBuffer, index: cubeIndexBuffer}],
            translation: translation,
            rotation: rotation,
            animate: animateFn
        };
    }

    function initFigures(gl) {
        var figures = [];

        var nullFn = function(){};

        var rotateFn = function() {
            this.rotation.x = this.rotation.x == 360 ? 0 : this.rotation.x + 1;
            this.rotation.y = this.rotation.y == 360 ? 0 : this.rotation.y + 2;
            //this.rotation.z = this.rotation.z == 360 ? 0 : this.rotation.z + 1;
        };

        figures.push(createCubeFigure(gl, [0.0, 0.0, -20.0], {x: 0.0, y: 0.0, z: 0.0}, rotateFn));

        return figures;
    }



    function drawScene(gl, shaderProgram, figures, texture, viewportWidth, viewportHeight) {
        // set up viewport and clear
        gl.viewport(0, 0, viewportWidth, viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // create perspective matrix and write into uniform
        var pMatrix = mat4.create();
        mat4.perspective(10, viewportWidth / viewportHeight, 0.1, 100.0, pMatrix);
        gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uPMatrix"), false, pMatrix);

        // draw figures
        figures.forEach(function(figure) {
            // create mv matrix, apply translation and rotation of figure, set mv uniform
            var mvMatrix = mat4.create();
            mat4.identity(mvMatrix);
            mat4.translate(mvMatrix, figure.translation);
            mat4.rotateX(mvMatrix, figure.rotation.x * Math.PI/180);
            mat4.rotateY(mvMatrix, figure.rotation.y * Math.PI/180);
            mat4.rotateZ(mvMatrix, figure.rotation.z * Math.PI/180);
            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMVMatrix"), false, mvMatrix);

            // draw buffers
            figure.buffers.forEach(function(buffer) {
                // set position attrib
                var positionBuffer = buffer.position;
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.vertexAttribPointer(gl.getAttribLocation(shaderProgram, "aVertexPosition"), positionBuffer.itemSize, gl.FLOAT, false, 0, 0);

                // set texture attrib
                var textureBuffer = buffer.texture;
                gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);
                gl.vertexAttribPointer(gl.getAttribLocation(shaderProgram, "aTextureCoord"), textureBuffer.itemSize, gl.FLOAT, false, 0, 0);
                
                // bind to texture (lol changeme)
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.uniform1i(gl.getUniformLocation(shaderProgram, "uSampler"), 0);

                // draw
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer.index);
                gl.drawElements(gl.TRIANGLES, buffer.index.numItems, gl.UNSIGNED_SHORT, 0);
            });
        });
    }

    function animateScene(figures) {
        figures.forEach(function(figure) { 
            figure.animate();
        });
    }

    function loadTexture(gl) { 
        var t = gl.createTexture();
        t.image = new Image();
        t.image.onload = function() {
            gl.bindTexture(gl.TEXTURE_2D, t);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.bindTexture(gl.TEXTURE_2D, null);
        };
        t.image.src = "crate.gif";
        return t;
    }

    function webGlInit() {
        var canvas =  document.getElementById("c");
        var gl = initGl(canvas);
        var shaderProgram = initShaders(gl);
        var texture = loadTexture(gl);
        var figures = initFigures(gl);
        return function() { // return function to update scene
            animateScene(figures);
            drawScene(gl, shaderProgram, figures, texture, canvas.width, canvas.height);
        };
    }

    function start() {
        var updateSceneFn = webGlInit();
        (function() {
            updateSceneFn();
            requestAnimationFrame(arguments.callee); // arguments.callee is a reference to this (anonymous) function
        })();
    }
</script>

</head>

<body onload="start();">
    <canvas id="c" style="border: none;" width="500" height="500"></canvas>
</body>

</html>