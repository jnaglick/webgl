<html>

<head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
    
<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;
    
    varying vec4 vColor;

    void main(void) {
        gl_FragColor = vColor;
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    uniform mat4 uPMatrix;
    uniform mat4 uMVMatrix;
    
    attribute vec4 aVertexColor;
    attribute vec3 aVertexPosition;
    
    varying vec4 vColor;

    void main(void) {
        vColor = aVertexColor;
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
    }
</script>

<script type="text/javascript">
    function initGl(canvas) {
        var gl = canvas.getContext("experimental-webgl");
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);
        return gl;
    }



    function createShader(gl, shaderType, shaderScriptId) {
        var shader = gl.createShader(shaderType);
        gl.shaderSource(shader, document.getElementById(shaderScriptId).text);
        gl.compileShader(shader)
        return shader;
    }

    function initShaders(gl) {
        var shaderProgram = gl.createProgram();

        gl.attachShader(shaderProgram, createShader(gl, gl.VERTEX_SHADER, "shader-vs"));
        gl.attachShader(shaderProgram, createShader(gl, gl.FRAGMENT_SHADER, "shader-fs"));

        gl.linkProgram(shaderProgram);

        gl.useProgram(shaderProgram);

        gl.enableVertexAttribArray(gl.getAttribLocation(shaderProgram, "aVertexPosition"));
        gl.enableVertexAttribArray(gl.getAttribLocation(shaderProgram, "aVertexColor"));

        return shaderProgram;
    }



    function createArrayBuffer(gl, options) {
        var b = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, b);
        if (typeof options !== 'undefined') { // copy properties from options to b
            Object.keys(options).forEach(function(k) {
                b[k] = options[k];
            });
        }
        return b;
    }

    function createPyramidFigure(gl, translation, rotation) {
        // triangles position
        var trianglesPositionBuffer = createArrayBuffer(gl, {
            itemSize: 3,
            numItems: 12,
            glDrawMode: gl.TRIANGLES
        });
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            // Front face
             0.0,  1.0,  0.0,
            -1.0, -1.0,  1.0,
             1.0, -1.0,  1.0,
            // Right face
             0.0,  1.0,  0.0,
             1.0, -1.0,  1.0,
             1.0, -1.0, -1.0,
            // Back face
             0.0,  1.0,  0.0,
             1.0, -1.0, -1.0,
            -1.0, -1.0, -1.0,
            // Left face
             0.0,  1.0,  0.0,
            -1.0, -1.0, -1.0,
            -1.0, -1.0,  1.0
        ]), gl.STATIC_DRAW);

        // triangles color
        var trianglesColorBuffer = createArrayBuffer(gl, {
            itemSize: 4
        });
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            // Front face
            1.0, 0.0, 0.0, 1.0,
            1.0, 0.0, 0.0, 1.0,
            1.0, 0.0, 0.0, 1.0,
            // Right face
            0.0, 1.0, 0.0, 1.0,
            0.0, 1.0, 0.0, 1.0,
            0.0, 1.0, 0.0, 1.0,
            // Back face
            0.0, 0.0, 1.0, 1.0,
            0.0, 0.0, 1.0, 1.0,
            0.0, 0.0, 1.0, 1.0,
            // Left face
            1.0, 1.0, 0.0, 1.0,
            1.0, 1.0, 0.0, 1.0,
            1.0, 1.0, 0.0, 1.0,
        ]), gl.STATIC_DRAW);

        // triangles buffer obj
        var trianglesBuffers = {
            position: trianglesPositionBuffer,
            color: trianglesColorBuffer
        };

        // bottom square position
        var squarePositionBuffer = createArrayBuffer(gl, {
            itemSize: 3,
            numItems: 4,
            glDrawMode: gl.TRIANGLE_STRIP
        });
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1.0, -1.0,  -1.0,
             1.0, -1.0,  -1.0,
            -1.0, -1.0,  1.0,
             1.0, -1.0,  1.0,
        ]), gl.STATIC_DRAW);

        // bottom square color
        var squareColorBuffer = createArrayBuffer(gl, {
            itemSize: 4
        });
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
             1.0, 1.0, 1.0, 1.0,
             1.0, 1.0, 1.0, 1.0,
             1.0, 1.0, 1.0, 1.0,
             1.0, 1.0, 1.0, 1.0
        ]), gl.STATIC_DRAW);

        // square buffer obj
        var squareBuffers = {
            position: squarePositionBuffer,
            color: squareColorBuffer
        };

        // finally, the pyramid figure
        return {
            buffers: [trianglesBuffers, squareBuffers],
            translation: translation,
            rotation: rotation
        };
    }

    function initFigures(gl) {
        var figures = [];

        figures.push(createPyramidFigure(gl, [5.0, 0.0, -70.0], {x: 0, y: 0, z: 0}));
        figures.push(createPyramidFigure(gl, [2.5, 0.0, -70.0], {x: 0, y: 0, z: 0}));
        figures.push(createPyramidFigure(gl, [0.0, 0.0, -70.0], {x: 0, y: 0, z: 0}));
        figures.push(createPyramidFigure(gl, [-2.5, 0.0, -70.0], {x: 0, y: 0, z: 0}));
        figures.push(createPyramidFigure(gl, [-5.0, 0.0, -70.0], {x: 0, y: 0, z: 0}));

        return figures;
    }



    function drawScene(gl, shaderProgram, figures, viewportWidth, viewportHeight) {
        // set up viewport and clear
        gl.viewport(0, 0, viewportWidth, viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // create perspective matrix and write into uniform
        var pMatrix = mat4.create();
        mat4.perspective(10, viewportWidth / viewportHeight, 0.1, 100.0, pMatrix);
        gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uPMatrix"), false, pMatrix);

        // draw figures
        figures.forEach(function(figure) {
            // create mv matrix, apply translation and rotation of figure, set mv uniform
            var mvMatrix = mat4.create();
            mat4.identity(mvMatrix);
            mat4.translate(mvMatrix, figure.translation);
            mat4.rotateX(mvMatrix, figure.rotation.x * Math.PI/180);
            mat4.rotateY(mvMatrix, figure.rotation.y * Math.PI/180);
            mat4.rotateZ(mvMatrix, figure.rotation.z * Math.PI/180);
            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMVMatrix"), false, mvMatrix);

            figure.buffers.forEach(function(buffer) {
                // set color attrib
                var color = buffer.color;
                gl.bindBuffer(gl.ARRAY_BUFFER, color);
                gl.vertexAttribPointer(gl.getAttribLocation(shaderProgram, "aVertexColor"), color.itemSize, gl.FLOAT, false, 0, 0);
               
                // set position attrib
                var position = buffer.position;
                gl.bindBuffer(gl.ARRAY_BUFFER, position);
                gl.vertexAttribPointer(gl.getAttribLocation(shaderProgram, "aVertexPosition"), position.itemSize, gl.FLOAT, false, 0, 0);

                // draw
                gl.drawArrays(position.glDrawMode, 0, position.numItems);
            });
        });
    }

    function animateScene(figures) {
        figures.forEach(function(figure) {
            figure.rotation.x = figure.rotation.x == 360 ? 0 : figure.rotation.x + 1;
            figure.rotation.y = figure.rotation.y == 360 ? 0 : figure.rotation.y + 1;
            figure.rotation.z = figure.rotation.z == 360 ? 0 : figure.rotation.z + 1;
        });
    }

    function webGlInit() {
        var canvas =  document.getElementById("c");
        var gl = initGl(canvas);
        var shaderProgram = initShaders(gl);
        var figures = initFigures(gl);
        return function() { // return function to update scene
            animateScene(figures);
            drawScene(gl, shaderProgram, figures, canvas.width, canvas.height);
        };
    }

    function start() {
        var updateSceneFn = webGlInit();
        (function() {
            updateSceneFn();
            requestAnimationFrame(arguments.callee); // arguments.callee is a reference to this (anonymous) function
        })();
    }
</script>

</head>

<body onload="start();">
    <canvas id="c" style="border: none;" width="500" height="500"></canvas>
</body>

</html>