<html>

<head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
    
<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;
    
    varying vec4 vColor;

    void main(void) {
        gl_FragColor = vColor;
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec4 aVertexColor;
    
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    
    varying vec4 vColor;

    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vColor = aVertexColor;
    }
</script>


<script type="text/javascript">
    function initGl(canvas) {
        var gl = canvas.getContext("experimental-webgl");
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);
        return gl;
    }



    function createShader(gl, shaderType, shaderScriptId) {
        var shader = gl.createShader(shaderType);
        gl.shaderSource(shader, document.getElementById(shaderScriptId).text);
        gl.compileShader(shader)
        return shader;
    }

    function initShaders(gl) {
        var shaderProgram = gl.createProgram();

        gl.attachShader(shaderProgram, createShader(gl, gl.VERTEX_SHADER, "shader-vs"));
        gl.attachShader(shaderProgram, createShader(gl, gl.FRAGMENT_SHADER, "shader-fs"));

        gl.linkProgram(shaderProgram);

        gl.useProgram(shaderProgram);

        gl.enableVertexAttribArray(gl.getAttribLocation(shaderProgram, "aVertexPosition"));
        gl.enableVertexAttribArray(gl.getAttribLocation(shaderProgram, "aVertexColor"));

        return shaderProgram;
    }



    function createArrayBuffer(gl, options) {
        var b = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, b);
        if (typeof options !== 'undefined') { // copy properties from options to b
            Object.keys(options).forEach(function(k) {
                b[k] = options[k];
            });
        }
        return b;
    }

    function initBuffers(gl) {
        var buffers = [];

        // position
        var trianglePositionBuffer = createArrayBuffer(gl, {
            itemSize: 3,
            numItems: 3,
            moveVector: [0.0, 0.0, -20.0],
            glDrawMode: gl.TRIANGLES
        });
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            0.0,  1.0,  0.0,
            -1.0, -1.0,  0.0,
            1.0, -1.0,  0.0
        ]), gl.STATIC_DRAW);

        // color
        var triangleColorBuffer = createArrayBuffer(gl, {
            itemSize: 4
        });
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            1.0, 0.0, 0.0, 1.0,
            0.0, 1.0, 0.0, 1.0,
            0.0, 0.0, 1.0, 1.0
        ]), gl.STATIC_DRAW);
        
        // dumb obj to contain 2 buffers corresponding to the same triangle
        // still using buffers array for now, will remove if i dont re-add more
        buffers.push({
            position: trianglePositionBuffer,
            color: triangleColorBuffer
        });

        return buffers;
    }



    function drawScene(gl, shaderProgram, buffers, viewportWidth, viewportHeight) {
        // set up viewport and clear
        gl.viewport(0, 0, viewportWidth, viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // create perspective matrix and write into uniform
        var pMatrix = mat4.create();
        mat4.perspective(10, viewportWidth / viewportHeight, 0.1, 100.0, pMatrix);
        gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uPMatrix"), false, pMatrix);

        // draw buffers
        buffers.forEach(function(buffer) {
            var posBuffer = buffer.position;
            var colorBuffer = buffer.color;
            
            // move model-view matrix to relative location specified by moveVector, write into gl uniform
            // create model-view matrix
            var mvMatrix = mat4.create();
            mat4.identity(mvMatrix);
            mat4.translate(mvMatrix, posBuffer.moveVector);
            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMVMatrix"), false, mvMatrix);            
         
            // set color attrib
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.vertexAttribPointer(gl.getAttribLocation(shaderProgram, "aVertexColor"), colorBuffer.itemSize, gl.FLOAT, false, 0, 0);
           
            // set position attrib
            gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
            gl.vertexAttribPointer(gl.getAttribLocation(shaderProgram, "aVertexPosition"), posBuffer.itemSize, gl.FLOAT, false, 0, 0);

            // draw posBuffer
            gl.drawArrays(posBuffer.glDrawMode, 0, posBuffer.numItems);
        });
    }



    function webGLStart() {
        var canvas =  document.getElementById("lesson01-canvas")

        var gl = initGl(canvas);

        var shaderProgram = initShaders(gl);

        var buffers = initBuffers(gl);

        drawScene(gl, shaderProgram, buffers, canvas.width, canvas.height);
    }
</script>


</head>


<body onload="webGLStart();">
    <canvas id="lesson01-canvas" style="border: none;" width="500" height="500"></canvas>
</body>

</html>
